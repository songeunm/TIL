# Redis 와 Memcached

[Velog](https://velog.io/@semoon/Redis-%EC%99%80-Memcached)<br>
# 📍 Redis

- Redis (Remote Dictionary Server)
- 오픈 소스 인메모리 데이터 구조 저장소
- DB, 캐시, 메시지 브로커, 세션 저장소 등으로 사용 가능
- **인메모리 저장소** → 데이터를 **메모리(RAM)에 저장** → 데이터 읽기·쓰기 **속도 빠름**
- **간단한 데이터 구조 처리**

### ✔️ 장점

- **빠른 데이터 처리**
    - 메모리 기반으로 데이터 처리 매우 빠름 (마이크로초 단위)
    - 디스크 I/O 필요하지 않음
- **다양한 데이터 구조 지원**
    - String, Hash, List, Set, Sorted Set, Bitmaps, HyperLogLog, Stream, …
- **단순한 사용**
    - 간단한 명령어, 데이터 구조로 사용이 단순
- **복제 및 클러스터링**
    - Master-Slave 복제를 지원하여 읽기 작업 분산
    - Redis Cluster를 통해 데이터를 여러 노드에 분산하여 처리 가능
- **Pub/Sub 지원**
    - 메시지 브로커로 사용할 수 있는 Publish(발행)/Subscribe(구독) 기능 제공
    - Publish
    특정 채널에 메시지를 발행
    - Subscribe
    클라이언트가 특정 채널을 구독하면 해당 채널로 발행된 메시지를 실시간으로 수신
    - 메시지는 즉시 subscriber에게 전달, 수신하지 못한 메시지는 저장되지 않음(공중분해)
    → 데이터가 영속적으로 저장될 필요가 없고, 즉각적 소비가 중요한 경우 사용 가능
    - Kafka에 비해 비교적 간단한 메시징 작업에 적합
    ex) 실시간 알림 시스템, 간단한 브로드캐스팅, 이벤트(일회성 데이터) 전달
- **스크립팅**
    - Lua 스크립트를 지원하여 복잡한 작업을 서버 측에서 실행 가능
    - SQL과 달리, 특정 Redis 데이터 구조를 조작하는 여러 Redis 명령어를 하나의 스크립트로 묶어 실행함을 의미
    (ex. 필터링, 간단한 가공)
    - 클라이언트-서버 간의 왕복 요청을 감소시킴
    - 작업의 원자성을 보장
- **멀티모델 데이터 저장**
    - 다양한 데이터 구조를 동시에 저장 및 조작 가능
    - 데이터 일관성 유지, 데이터 관리 용이
    - 다양한 데이터 저장 요구 충족 가능

### ✔️ 단점

- **메모리 의존성**
    - 데이터 크기가 메모리 용량을 초과하면, 성능이 저하되거나 사용이 제한 될 수 있음
- **비영속성**
    - 서버 종료 또는 재시작 시 데이터가 사라짐
    - 데이터를 디스크에 저장하는 기능을 제공하여 데이터 복구 가능
    (ex. RDB(Redis Database Snapshot), AOF(Append-Only File))
- **복잡한 쿼리 미지원**
    - SQL 사용 불가능
    - 데이터 조작은 애플리케이션에서 처리해야함
- **비용 문제**
    - 메모리는 디스크보다 비싸기 때문에 대규모 데이터를 저장 및 처리하기 위해서는 비용이 부담될 수 있음

### ✔️ 사용 사례

- 캐시 시스템
    - 자주 사용되는 데이터를 빠르게 액세스 가능 (ex. 사용자 세션, API 응답)
- 메시지 브로커
    - Pub/Sub 시스템을 활용해 채팅 애플리케이션, 알림 시스템 등에 이용 가능
- 실시간 분석
    - 실시간 클릭 스트림 데이터 저장 및 처리에 이용 가능
- 순위 및 리더보드
    - Sorted Set(ZSet)을 사용해 리더보드(랭킹) 구현 가능
- 큐 및 작업 스케줄링
    - List를 사용하여 작업 큐를 관리 가능

# 📍 Memcached

- 단순하고 빠른 분산 인메모리 캐싱 시스템
- 자주 사용되는 데이터나 요청 결과를 RAM에 캐싱
- DB나 애플리케이션의 응답 속도를 크게 향상시키는데 사용
- 오픈 소스 소프트웨어
- 대규모 웹 애플리케이션에서 자주 활용

### ✔️ 동작 방식

- **Key-Value 데이터 저장**
- **TTL(Time-To-Live) 설정**
    - 데이터를 캐시에 저장할 때 유효기간(TTL)을 설정 가능
    - TTL 만료시 해당 데이터 자동 삭제
- **분산 캐싱**
    - 여러 Memcached 서버를 클러스터로 구성하여 데이터를 분산 처리
- **LRU(Least Recently Used)**
    - 메모리 부족시, 오래된 데이터부터 삭제하여 새 데이터 저장

### ✔️ 장점

- **인메모리 캐싱**
    - 모든 데이터를 메모리(RAM)에 저장하여 초고속으로 데이터 읽기·쓰기 가능
- **Key-Value 저장소**
    - 간단한 Key-Value 데이터 구조를 사용하여 데이터 저장
- **분산 처리 지원**
    - 여러 서버로 데이터를 분산 저장하여 확장 가능
- **경량화 설계**
    - 가벼운 프로세스와 최소한의 리소스를 사용하여 효율적
- **오픈 소스**
    - 무료이기 때문에 비용 부담 적음

### ✔️ 단점

- **데이터 영속성 부족**
    - 데이터를 메모리에만 저장해 서버가 종료되면 데이터가 사라짐
- **복잡한 데이터 구조 미지원**
    - Redis처럼 다양한 데이터 구조(List, Set 등)를 지원하지 않음
- **데이터 검색 제한**
    - 데이터를 Key로만 검색할 수 있음
    - Value 기반 검색 불가능
- **보안 부족**
    - 기본적으로 인증과 암호화 기능이 없어 보안 위험이 있음

### ✔️ 사용 사례

- 단순한 캐싱 시스템이 필요한 경우
- 데이터 영속성, 복잡한 데이터 구조가 필요 없는 애플리케이션
- 비용이 제한적이며 최대 성능이 필요한 웹 애플리케이션
